docker run redis:4.0   #запуск контейнера с redis определенной версии, 4.0 - это так называемый tag
# без указания tag по умолчанию будет latest
# пример: если у нас есть некое приложение-скрипт, которое при запуске выдает "Welcome! Please enter your name:" 
# и выводит на экран "Hello and Welcome Aidar!" после ввода имени пользователя
# по умолчанию docker контейнер не слушает standard input, соответственно наше приложение в контейнере не спросит имя юзера и просто выведет:
# "Hello and Welcome!"
docker run -i kodekloud/simple-prompt-docker   #i=interactive-mode, позволит нам ввести имя пользователя и получить желаемый вывод, 
# но не покажет prompt скрипта "Welcome! Please enter your name:", т.к. приложение выводит в терминал, который не приаттачен к терминалу контейнера
docker run -it kodekloud/simple-prompt-docker   #t=pseudo-terminal, позволяет нам решить эту проблему

# пример: приложение запущенное в контейнере слушает на порту 5000, соответственно получить к нему доступ можно двумя способами:
# по внутреннему ip контейнера, который доступен только с docker-хоста, соответственно извне доступа не будет
# нужно настроить маппинг порта внутри docker-контейнера на свободный порт на docker-хосте
docker run -p 80:5000 kodekloud/webapp   #сначала указываем порт на docker-хосте, затем порт контейнера
docker run -p 8000:5000 kodekloud/webapp   #можно запустить несколько инстансов приложения и смаппить их на разные порты

# пример: мы запускаем контейнер с mysql, когда создаются БД и таблицы data-файлы сохраняются в /var/lib/mysql внутри контейнера
# соответственно, если мы удалим контейнер, то и все данные тоже исчезнут
# но мы можем сохранить данные с помощью маппинга:
docker run -v /opt/datadir:/var/lib/mysql mysql   #сначала указываем папку на docker-хосте, затем папку в контейнере

docker inspect container_name   #смотреть подробную инфу о контейнере
docker logs container_name   #смотреть логи контейнера, если мы изначально запустили его в detached-mode
